/* Copyright (c) 2005-2008, Torbjorn Ekman
 *                    2013, Jesper Ã–qvist <jesper.oqvist@cs.lth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

import java.util.*;
import java.io.*;

aspect CreateBCode {

  inh TypeDecl CatchClause.hostType();

  public abstract void CatchClause.exceptionTableEntries(CodeGeneration gen, int begin_lbl, int end_lbl);

  public void BasicCatch.exceptionTableEntries(CodeGeneration gen, int begin_lbl, int end_lbl) {
    gen.addException(
      begin_lbl,
      end_lbl,
      label(),
      gen.constantPool().addClass(getParameter().type().constantPoolName())
    );
  }

  syn lazy boolean TypeDecl.hasClinit() {
    for(int i = 0; i < getNumBodyDecl(); i++) {
      BodyDecl b = getBodyDecl(i);
      if(b instanceof FieldDeclaration) {
        FieldDeclaration f = (FieldDeclaration)b;
        if(f.isStatic() && f.hasInit()) {
          return true;
        }
      }
      else if(b instanceof StaticInitializer) {
        return true;
      }
    }
    return false;
  }

  syn lazy CodeGeneration TypeDecl.bytecodes(ConstantPool constantPool) {
    CodeGeneration gen = new CodeGeneration(constantPool);
    generateBytecodes(gen);
    if(!gen.numberFormatError())
      return gen;
    gen = new CodeGeneration(constantPool, true);
    generateBytecodes(gen);
    if(!gen.numberFormatError())
      return gen;
    throw new Error("Could not generate code for initializers in " + hostType().typeName());
  }

  private void TypeDecl.generateBytecodes(CodeGeneration gen) {
    for (int i = 0; i < getNumBodyDecl(); i++) {
      BodyDecl b = getBodyDecl(i);
      if (b instanceof FieldDeclaration && b.isBytecodeField()) {
        FieldDeclaration f = (FieldDeclaration)b;
        f.emitStaticInitializer(gen, this);
      } else if (b instanceof StaticInitializer) {
        b.createBCode(gen);
      }
    }
    gen.emitReturn();
  }

  syn lazy CodeGeneration MethodDecl.bytecodes(ConstantPool constantPool) {
    //if(options().verbose())
    //  System.out.println("Generating bytecodes for " + signature() + " in " + hostType().fullName());
    CodeGeneration gen = new CodeGeneration(constantPool);
    generateBytecodes(gen);
    if(!gen.numberFormatError())
      return gen;
    gen = new CodeGeneration(constantPool, true);
    generateBytecodes(gen);
    if(!gen.numberFormatError())
      return gen;
    throw new Error("Could not generate code for " + signature() + " in " + hostType().typeName());
  }
  private void MethodDecl.generateBytecodes(CodeGeneration gen) {
    int label = gen.variableScopeLabel();
    if(!isStatic())
      gen.addLocalVariableEntryAtCurrentPC("this", hostType().typeDescriptor(), 0, label);
    for(int i = 0; i < getNumParameter(); i++) {
      ParameterDeclaration p = (ParameterDeclaration)getParameter(i);
      gen.addLocalVariableEntryAtCurrentPC(
        p.name(), p.type().typeDescriptor(), p.localNum(), label
      );
    }
    createBCode(gen);
    if(type() instanceof VoidType) // TODO: canCompleteNormally check as well
      gen.emitReturn();
    gen.addVariableScopeLabel(label);
  }

  syn lazy CodeGeneration ConstructorDecl.bytecodes(ConstantPool constantPool) {
    CodeGeneration gen = new CodeGeneration(constantPool);
    generateBytecodes(gen);
    if(!gen.numberFormatError())
      return gen;
    gen = new CodeGeneration(constantPool, true);
    generateBytecodes(gen);
    if(!gen.numberFormatError())
      return gen;
    throw new Error("Could not generate code for " + signature() + " in " + hostType().typeName());
  }
  private void ConstructorDecl.generateBytecodes(CodeGeneration gen) {
    int label = gen.variableScopeLabel();
    gen.addLocalVariableEntryAtCurrentPC("this", hostType().typeDescriptor(), 0, label);
    for(int i = 0; i < getNumParameter(); i++) {
      ParameterDeclaration p = (ParameterDeclaration)getParameter(i);
      gen.addLocalVariableEntryAtCurrentPC(
        p.name(), p.type().typeDescriptor(), p.localNum(), label
      );
    }
    createBCode(gen);
    gen.emitReturn();
    gen.addVariableScopeLabel(label);
  }

  public void MethodDecl.createBCode(CodeGeneration gen) {
    try {
      if(hasBlock()) {
        gen.maxLocals = Math.max(gen.maxLocals, getBlock().localNum());
        getBlock().createBCode(gen);
      }
    } catch (Error e) {
      System.err.println(hostType().typeName() + ": " + this);
      throw e;
    }
  }

  public void ConstructorDecl.createBCode(CodeGeneration gen) {
    try {
    boolean needsInit = true;

    if(hasConstructorInvocation()) {
      getConstructorInvocation().createBCode(gen);
      Stmt stmt = getConstructorInvocation();
      if(stmt instanceof ExprStmt) {
        ExprStmt exprStmt = (ExprStmt)stmt;
        Expr expr = exprStmt.getExpr();
        if(!expr.isSuperConstructorAccess())
          needsInit = false;

      }
    }

    if(needsEnclosing()) {
      gen.emitLoadReference(0);
      gen.emitLoadReference(1);
      String classname = hostType().constantPoolName();
      String desc = enclosing().typeDescriptor();
      String name = "this$0";
      int index = gen.constantPool().addFieldref(classname, name, desc);
      gen.emit(Bytecode.PUTFIELD, -2).add2(index);
    }

    int localIndex = offsetFirstEnclosingVariable();
    for(Iterator iter = hostType().enclosingVariables().iterator(); iter.hasNext(); ) {
        Variable v = (Variable)iter.next();
        gen.emitLoadReference(0);
        v.type().emitLoadLocal(gen, localIndex);
        String classname = hostType().constantPoolName();
        String desc = v.type().typeDescriptor();
        String name = "val$" + v.name();
        int index = gen.constantPool().addFieldref(classname, name, desc);
        gen.emit(Bytecode.PUTFIELD, -1 - v.type().variableSize()).add2(index);
        localIndex += v.type().variableSize();
    }

    if (needsInit) {
      TypeDecl typeDecl = hostType();
      for (int i = 0; i < typeDecl.getNumBodyDecl(); i++) {
        BodyDecl b = typeDecl.getBodyDecl(i);
        if (b instanceof FieldDeclaration && b.isBytecodeField()) {
          FieldDeclaration f = (FieldDeclaration)b;
          f.emitInstanceInitializer(gen, hostType());
        } else if (b instanceof InstanceInitializer) {
          b.createBCode(gen);
        }
      }
    }
    gen.maxLocals = Math.max(gen.maxLocals, getBlock().localNum());
    getBlock().createBCode(gen);
    } catch (Error e) {
      System.err.println(hostType().typeName() + ": " + this);
      throw e;
    }
  }

  public void ASTNode.createBCode(CodeGeneration gen) {
    for (int i=0; i<getNumChild(); i++)
      getChild(i).createBCode(gen);
  }

  public void Literal.createBCode(CodeGeneration gen) {
    emitPushConstant(gen);
  }

  protected boolean Expr.needsPush() {
    ASTNode n = getParent();
    while(n instanceof ParExpr)
      n = n.getParent();
    return !(n instanceof ExprStmt);
  }

  syn boolean ExprStmt.needsPop() = getExpr().needsPop();
  syn boolean Expr.needsPop() = true;
  eq AbstractDot.needsPop() = lastAccess().needsPop();
  eq ConstructorAccess.needsPop() = false;

  eq ParExpr.needsPop() = getExpr().needsPop();
  //eq AssignExpr.needsPop() = false; // if dest is instance variable that needs accessor
  eq AssignExpr.needsPop() = getDest().isVarAccessWithAccessor();
  eq PreIncExpr.needsPop() = false;
  eq PostIncExpr.needsPop() = getOperand().isVarAccessWithAccessor();
  eq PreDecExpr.needsPop() = false;
  eq PostDecExpr.needsPop() = getOperand().isVarAccessWithAccessor();

  syn boolean Expr.isVarAccessWithAccessor() = false;
  eq ParExpr.isVarAccessWithAccessor() = getExpr().isVarAccessWithAccessor();
  eq AbstractDot.isVarAccessWithAccessor() = lastAccess().isVarAccessWithAccessor();
  eq VarAccess.isVarAccessWithAccessor() = decl() instanceof FieldDeclaration &&
        decl().isInstanceVariable() && requiresAccessor();

  public void VariableDeclaration.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    if (hasInit()) {
      gen.addLocalVariableEntryAtCurrentPC(name(), type().typeDescriptor(), localNum(), variableScopeEndLabel(gen));
      emitInitializerBCode(gen);
      type().emitStoreLocal(gen, localNum());
    }
  }

  /**
   * Generate variable initialization bytecode.
   */
  protected void VariableDeclaration.emitInitializerBCode(CodeGeneration gen) {
    getInit().createBCode(gen);
    getInit().type().emitAssignConvTo(gen, type());
  }

  /**
   * Generate static initialization code for the field.
   */
  public void FieldDeclaration.emitStaticInitializer(CodeGeneration gen, TypeDecl hostType) {
    if (isStatic() && hasInit()) {
      emitInitializerBCode(gen);
      emitStoreField(gen, hostType);
    }
  }

  /**
   * Generate instance initialization code for the field.
   */
  public void FieldDeclaration.emitInstanceInitializer(CodeGeneration gen, TypeDecl hostType) {
    if (!isStatic() && hasInit()) {
      gen.emit(Bytecode.ALOAD_0);
      emitInitializerBCode(gen);
      emitStoreField(gen, hostType);
    }
  }

  /**
   * Generate field initialization bytecode.
   */
  protected void FieldDeclaration.emitInitializerBCode(CodeGeneration gen) {
    getInit().createBCode(gen);
    getInit().type().emitAssignConvTo(gen, type());
  }

  /**
   * Create bytecode for a simple assign expression.
   */
  public void AssignSimpleExpr.createBCode(CodeGeneration gen) {
    getDest().createAssignSimpleLoadDest(gen);
    getSource().createBCode(gen);
    getSource().type().emitAssignConvTo(gen, getDest().type()); // AssignConversion
    if(needsPush()) {
      getDest().createPushAssignmentResult(gen);
    }
    getDest().emitStore(gen);
  }

  /**
   * Create bytecode for a compund assign expression.
   */
  public void AssignExpr.createBCode(CodeGeneration gen) {
    TypeDecl dest = getDest().type();
    TypeDecl source = getSource().type();
    TypeDecl type;
    if(dest.isNumericType() && source.isNumericType())
      type = dest.binaryNumericPromotion(source);
    else
      type = dest;
    getDest().createAssignLoadDest(gen);
    dest.emitCastTo(gen, type);
    getSource().createBCode(gen);
    source.emitCastTo(gen, type);
    createAssignOp(gen, type);
    type.emitCastTo(gen, dest);
    if(needsPush()) {
      getDest().createPushAssignmentResult(gen);
    }
    getDest().emitStore(gen);
  }

  // string addition assign expression
  public void AssignPlusExpr.createBCode(CodeGeneration gen) {
    TypeDecl dest = getDest().type();
    TypeDecl source = getSource().type();
    if(dest.isString()) {
      getDest().createAssignLoadDest(gen);

      // new StringBuffer()
      TypeDecl stringBuffer = lookupType("java.lang", "StringBuffer");
      String classname = stringBuffer.constantPoolName();
      String desc;
      int index;
      TypeDecl argumentType;
      stringBuffer.emitNew(gen); // new StringBuffer
      gen.emitDup();             // dup
      desc = "()V";
      index = gen.constantPool().addMethodref(classname, "<init>", desc);
      gen.emit(Bytecode.INVOKESPECIAL, -1).add2(index); // invokespecial StringBuffer()

      gen.emitSwap();

      // append
      argumentType = dest.stringPromotion();
      desc = "(" + argumentType.typeDescriptor() + ")" + stringBuffer.typeDescriptor();
      index = gen.constantPool().addMethodref(classname, "append", desc);
      gen.emit(Bytecode.INVOKEVIRTUAL, -argumentType.variableSize()).add2(index); // StringBuffer.append

      getSource().createBCode(gen);

      // typed append
      argumentType = source.stringPromotion();
      desc = "(" + argumentType.typeDescriptor() + ")" + stringBuffer.typeDescriptor();
      index = gen.constantPool().addMethodref(classname, "append", desc);
      gen.emit(Bytecode.INVOKEVIRTUAL, -argumentType.variableSize()).add2(index); // StringBuffer.append

      // toString
      desc = "()" + type().typeDescriptor();
      index = gen.constantPool().addMethodref(classname, "toString", desc);
      gen.emit(Bytecode.INVOKEVIRTUAL, 0).add2(index); // StringBuffer.toString

      if (needsPush()) {
        getDest().createPushAssignmentResult(gen);
      }
      getDest().emitStore(gen);
    }
    else {
      super.createBCode(gen);
    }
  }

  // shift assign expression
  public void AssignExpr.emitShiftExpr(CodeGeneration gen) {
    TypeDecl dest = getDest().type();
    TypeDecl source = getSource().type();
    TypeDecl type = dest.unaryNumericPromotion();
    getDest().createAssignLoadDest(gen);
    dest.emitCastTo(gen, type);
    getSource().createBCode(gen);
    source.emitCastTo(gen, typeInt());
    createAssignOp(gen, type);
    type.emitCastTo(gen, dest);
    if(needsPush()) {
      getDest().createPushAssignmentResult(gen);
    }
    getDest().emitStore(gen);
  }
  public void AssignLShiftExpr.createBCode(CodeGeneration gen) { emitShiftExpr(gen); }
  public void AssignRShiftExpr.createBCode(CodeGeneration gen) { emitShiftExpr(gen); }
  public void AssignURShiftExpr.createBCode(CodeGeneration gen) { emitShiftExpr(gen); }

  // load left hand side of destination in a simple assign expression
  public void Expr.createAssignSimpleLoadDest(CodeGeneration gen) {
  }
  public void AbstractDot.createAssignSimpleLoadDest(CodeGeneration gen) {
    lastAccess().createAssignSimpleLoadDest(gen);
  }
  public void VarAccess.createAssignSimpleLoadDest(CodeGeneration gen) {
    createLoadQualifier(gen);
  }
  public void ArrayAccess.createAssignSimpleLoadDest(CodeGeneration gen) {
    prevExpr().createBCode(gen);
    getExpr().createBCode(gen);
  }

  /**
   * duplicate top value on stack and store below destination element
   */
  public void Expr.createPushAssignmentResult(CodeGeneration gen) {
  }
  public void AbstractDot.createPushAssignmentResult(CodeGeneration gen) {
    lastAccess().createPushAssignmentResult(gen);
  }
  public void VarAccess.createPushAssignmentResult(CodeGeneration gen) {
    if(hostType().needsAccessorFor(decl()))
      return;
    if(decl().isInstanceVariable())
      type().emitDup_x1(gen);
    else
      type().emitDup(gen);
  }
  public void ArrayAccess.createPushAssignmentResult(CodeGeneration gen) {
    type().emitDup_x2(gen);
  }

  // load left hand side of destination in a compound assign expression
  public void Expr.createAssignLoadDest(CodeGeneration gen) {
  }
  public void AbstractDot.createAssignLoadDest(CodeGeneration gen) {
    lastAccess().createAssignLoadDest(gen);
  }
  public void VarAccess.createAssignLoadDest(CodeGeneration gen) {
    createLoadQualifier(gen);
    Variable v = decl();
    if(v.isInstanceVariable())
      gen.emitDup();
    if(v instanceof VariableDeclaration) {
      VariableDeclaration decl = (VariableDeclaration)v;
      decl.type().emitLoadLocal(gen, decl.localNum());
    }
    else if(v instanceof ParameterDeclaration) {
      ParameterDeclaration decl = (ParameterDeclaration)v;
      decl.type().emitLoadLocal(gen, decl.localNum());
    }
    else if(v instanceof FieldDeclaration) {
      FieldDeclaration f = (FieldDeclaration)v;
      if(requiresAccessor())
        f.createAccessor(fieldQualifierType()).emitInvokeMethod(gen, fieldQualifierType());
      else
        f.emitLoadField(gen, fieldQualifierType());
    }
  }
  public void ArrayAccess.createAssignLoadDest(CodeGeneration gen) {
    prevExpr().createBCode(gen);
    gen.emitDup();
    getExpr().createBCode(gen);
    typeInt().emitDup_x1(gen);
    gen.emit(type().arrayLoad());
  }

  // select the typed operation for a compound assign expression
  public void AssignExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    throw new Error("Operation createAssignOp is not implemented for " + getClass().getName());
  }
  public void AssignMulExpr.createAssignOp(CodeGeneration gen, TypeDecl type)     { type.mul(gen); }
  public void AssignDivExpr.createAssignOp(CodeGeneration gen, TypeDecl type)     { type.div(gen); }
  public void AssignModExpr.createAssignOp(CodeGeneration gen, TypeDecl type)     { type.rem(gen); }
  public void AssignPlusExpr.createAssignOp(CodeGeneration gen, TypeDecl type)    { type.add(gen); }
  public void AssignMinusExpr.createAssignOp(CodeGeneration gen, TypeDecl type)   { type.sub(gen); }
  public void AssignLShiftExpr.createAssignOp(CodeGeneration gen, TypeDecl type)  { type.shl(gen); }
  public void AssignRShiftExpr.createAssignOp(CodeGeneration gen, TypeDecl type)  { type.shr(gen); }
  public void AssignURShiftExpr.createAssignOp(CodeGeneration gen, TypeDecl type) { type.ushr(gen); }
  public void AssignAndExpr.createAssignOp(CodeGeneration gen, TypeDecl type)     { type.bitand(gen); }
  public void AssignXorExpr.createAssignOp(CodeGeneration gen, TypeDecl type)     { type.bitxor(gen); }
  public void AssignOrExpr.createAssignOp(CodeGeneration gen, TypeDecl type)      { type.bitor(gen); }

  public void AbstractDot.createBCode(CodeGeneration gen) {
    lastAccess().createBCode(gen);
  }

  public void VarAccess.createBCode(CodeGeneration gen) {
    Variable v = decl();
    if(v instanceof VariableDeclaration) {
      VariableDeclaration decl = (VariableDeclaration)v;
      if(decl.hostType() == hostType())
        decl.type().emitLoadLocal(gen, decl.localNum());
      else
        emitLoadLocalInNestedClass(gen, decl);
    }
    else if(v instanceof ParameterDeclaration) {
      ParameterDeclaration decl = (ParameterDeclaration)v;
      if(decl.hostType() == hostType())
        decl.type().emitLoadLocal(gen, decl.localNum());
      else
        emitLoadLocalInNestedClass(gen, decl);
    }
    else if(v instanceof FieldDeclaration) {
      FieldDeclaration f = (FieldDeclaration)v;
      createLoadQualifier(gen);
      if(f.isConstant() && (f.type().isPrimitive() || f.type().isString())) {
        if(!f.isStatic())
          fieldQualifierType().emitPop(gen);
        f.constant().createBCode(gen);
      }
      else if(requiresAccessor())
        f.createAccessor(fieldQualifierType()).emitInvokeMethod(gen, fieldQualifierType());
      else
        f.emitLoadField(gen, fieldQualifierType());
    }
  }

  syn boolean TypeDecl.needsAccessorFor(Variable v) {
    if(!(v instanceof FieldDeclaration))
      return false;
    FieldDeclaration f = (FieldDeclaration)v;
    if(f.isConstant() && (f.type().isPrimitive() || f.type().isString()))
      return false;
    return f.isPrivate() && !hasField(v.name());
  }

  inh boolean Access.inExplicitConstructorInvocation();
  public void Access.emitLoadLocalInNestedClass(CodeGeneration gen, Variable v) {
    if(inExplicitConstructorInvocation() && enclosingBodyDecl() instanceof ConstructorDecl) {
      ConstructorDecl c = (ConstructorDecl)enclosingBodyDecl();
      v.type().emitLoadLocal(gen, c.localIndexOfEnclosingVariable(v));
    }
    else {
      String classname = hostType().constantPoolName();
      String      desc = v.type().typeDescriptor();
      String      name = "val$" + v.name();
      int index = gen.constantPool().addFieldref(classname, name, desc);
      gen.emit(Bytecode.ALOAD_0);
      gen.emit(Bytecode.GETFIELD, v.type().variableSize() - 1).add2(index);
    }
  }

  protected void VarAccess.createLoadQualifier(CodeGeneration gen) {
    Variable v = decl();
    if(v instanceof FieldDeclaration) {
      FieldDeclaration f = (FieldDeclaration)v;
      if(hasPrevExpr()) {
        // load explicit qualifier
        prevExpr().createBCode(gen);
        // pop qualifier stack element for class variables
        // this qualifier must be computed to ensure side effects
        if(!prevExpr().isTypeAccess() && f.isClassVariable())
          prevExpr().type().emitPop(gen);
      }
      else if(f.isInstanceVariable()) {
        emitThis(gen, fieldQualifierType());
      }
    }
  }

  public void MethodAccess.createBCode(CodeGeneration gen) {
    createLoadQualifier(gen);

    if (options().hasOption("-debug")) {
      if (decl().type().isUnknown()) {
        System.err.println("Could not bind " + this);
        for (int i = 0; i < getNumArg(); ++i) {
          System.err.println("Argument " + getArg(i) +
              " is of type " + getArg(i).type().typeName());
          if (getArg(i).varDecl() != null) {
            System.err.println(getArg(i).varDecl() + " in " +
                getArg(i).varDecl().hostType().typeName());
          }
        }
        if (isQualified()) {
          System.err.println("Qualifier " + qualifier() +
              " is of type " + qualifier().type().typeName());
        }
        throw new Error("Could not bind " + this);
      }
      if (decl().getNumParameter() != getNumArg()) {
        System.err.println(this +
            " does not have the same number of arguments as " + decl());
      }
    }

    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      getArg(i).type().emitCastTo(gen, decl().getParameter(i).type()); // MethodInvocationConversion
    }

    if (!decl().isStatic() && isQualified() && prevExpr().isSuperAccess()) {
      if (!hostType().instanceOf(prevExpr().type())) {
        decl().createSuperAccessor(superAccessorTarget()).emitInvokeMethod(gen, superAccessorTarget());
      } else {
        decl().emitInvokeSpecialMethod(gen, methodQualifierType());
      }
    } else {
      decl().emitInvokeMethod(gen, methodQualifierType());
    }
  }

  protected void MethodAccess.createLoadQualifier(CodeGeneration gen) {
    MethodDecl m = decl();
    if(hasPrevExpr()) {
      // load explicit qualifier
      prevExpr().createBCode(gen);
      // pop qualifier stack element for class variables
      // this qualifier must be computed to ensure side effects
      if(m.isStatic() && !prevExpr().isTypeAccess())
        prevExpr().type().emitPop(gen);
    }
    else if(!m.isStatic()) {
      // load implicit this qualifier
      emitThis(gen, methodQualifierType());
    }
  }

  public void ArrayAccess.createBCode(CodeGeneration gen) {
    prevExpr().createBCode(gen);
    getExpr().createBCode(gen);
    gen.emit(type().arrayLoad());
  }

  public void ThisAccess.createBCode(CodeGeneration gen) {
    emitThis(gen, decl());
  }
  public void SuperAccess.createBCode(CodeGeneration gen) {
    emitThis(gen, decl());
  }

  // load this where hostType is the target this instance
  // supporting inner classes and in explicit contructor invocations
  public void Access.emitThis(CodeGeneration gen, TypeDecl targetDecl) {
    if(targetDecl == hostType())
      gen.emit(Bytecode.ALOAD_0);
    else {
      TypeDecl enclosing = hostType();
      if(inExplicitConstructorInvocation()) {
        gen.emit(Bytecode.ALOAD_1);
        enclosing = enclosing.enclosing();
      }
      else {
        gen.emit(Bytecode.ALOAD_0);
      }
      while(enclosing != targetDecl) {
        String classname = enclosing.constantPoolName();
        enclosing = enclosing.enclosingType();
        String desc = enclosing.typeDescriptor();
        int index = gen.constantPool().addFieldref(classname, "this$0", desc);
        gen.emit(Bytecode.GETFIELD, 0).add2(index);
      }
    }
  }


  public void ConstructorAccess.createBCode(CodeGeneration gen) {
    ConstructorDecl c = decl();
    int index = 0;
    // this
    gen.emitLoadReference(index++);
    // this$0
    if(c.needsEnclosing())
      gen.emitLoadReference(index++);
    if(c.needsSuperEnclosing())
      gen.emitLoadReference(index++);

    // args
    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      getArg(i).type().emitCastTo(gen, decl().getParameter(i).type()); // MethodInvocationConversion
    }
    if(decl().isPrivate() && decl().hostType() != hostType()) {
      gen.emit(Bytecode.ACONST_NULL);
      decl().createAccessor().emitInvokeConstructor(gen);
    }
    else {
      decl().emitInvokeConstructor(gen);
    }
  }

  public void SuperConstructorAccess.createBCode(CodeGeneration gen) {
    ConstructorDecl c = decl();

    // this
    gen.emit(Bytecode.ALOAD_0);

    if(c.needsEnclosing()) {
      if(hasPrevExpr() && !prevExpr().isTypeAccess()) {
        prevExpr().createBCode(gen);
        gen.emitDup();
        int index = gen.constantPool().addMethodref("java/lang/Object", "getClass", "()Ljava/lang/Class;");
        gen.emit(Bytecode.INVOKEVIRTUAL, 0).add2(index);
        gen.emitPop();
      }
      else {
        if(hostType().needsSuperEnclosing()) {
          if(hostType().needsEnclosing())
            gen.emit(Bytecode.ALOAD_2);
          else
            gen.emit(Bytecode.ALOAD_1);
        }
        else {
          emitThis(gen, superConstructorQualifier(c.hostType().enclosingType()));
        }
      }
    }

    // args
    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      getArg(i).type().emitCastTo(gen, decl().getParameter(i).type()); // MethodInvocationConversion
    }
    if(decl().isPrivate() && decl().hostType() != hostType()) {
      gen.emit(Bytecode.ACONST_NULL);
      decl().createAccessor().emitInvokeConstructor(gen);
    }
    else {
      decl().emitInvokeConstructor(gen);
    }
  }

  // 15.9.2
  private void ClassInstanceExpr.emitLocalEnclosing(CodeGeneration gen, TypeDecl localClass) {
    if(!localClass.inStaticContext()) {
      emitThis(gen, localClass.enclosingType());
    }
  }
  private void ClassInstanceExpr.emitInnerMemberEnclosing(CodeGeneration gen, TypeDecl innerClass) {
    if(hasPrevExpr()) {
      prevExpr().createBCode(gen);
      gen.emitDup();
      int index = gen.constantPool().addMethodref("java/lang/Object", "getClass", "()Ljava/lang/Class;");
      gen.emit(Bytecode.INVOKEVIRTUAL, 0).add2(index);
      gen.emitPop();
    }
    else {
      TypeDecl enclosing = hostType();
      while(enclosing != null && !enclosing.hasType(innerClass.name()))
        enclosing = enclosing.enclosingType();
      if(enclosing == null)
        throw new Error(errorPrefix() + "Could not find enclosing for " + this);
      else
        emitThis(gen, enclosing);
    }
  }
  public void ClassInstanceExpr.createBCode(CodeGeneration gen) {
    type().emitNew(gen);
    type().emitDup(gen);

    // 15.9.2 first part
    if(type().isAnonymous()) {
      if(type().isAnonymousInNonStaticContext()) {
        if(type().inExplicitConstructorInvocation())
          gen.emit(Bytecode.ALOAD_1);
        else
          gen.emit(Bytecode.ALOAD_0);
      }
      // 15.9.2 second part
      ClassDecl C = (ClassDecl)type();
      TypeDecl S = C.superclass();
      if(S.isLocalClass()) {
        if(!type().inStaticContext())
          emitLocalEnclosing(gen, S);
      }
      else if(S.isInnerType()) {
        emitInnerMemberEnclosing(gen, S);
      }
    }
    else if(type().isLocalClass()) {
      if(!type().inStaticContext())
        emitLocalEnclosing(gen, type());
    }
    else if(type().isInnerType()) {
      emitInnerMemberEnclosing(gen, type());
    }
    /*
    // 15.9.2 first part
    if(type().isAnonymous()) {
      if(type().isAnonymousInNonStaticContext()) {
        if(type().inExplicitConstructorInvocation())
          gen.emit(Bytecode.ALOAD_1);
        else
          gen.emit(Bytecode.ALOAD_0);
      }
      if(type().needsSuperEnclosing()) {
        // 15.9.2 second part
        ClassDecl C = (ClassDecl)type();
        TypeDecl S = C.superclass();
        if(S.isLocalClass()) {
          emitLocalEnclosing(gen, S);
        }
        else if(S.isInnerType()) {
          emitInnerMemberEnclosing(gen, S);
        }
      }
    }
    else if(type().isLocalClass()) {
      emitLocalEnclosing(gen, type());
    }
    else if(type().isInnerType()) {
      emitInnerMemberEnclosing(gen, type());
    }
    */

    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      getArg(i).type().emitCastTo(gen, decl().getParameter(i).type()); // MethodInvocationConversion
    }

    if(decl().isPrivate() && type() != hostType()) {
      gen.emit(Bytecode.ACONST_NULL);
      decl().createAccessor().emitInvokeConstructor(gen);
    }
    else {
      decl().emitInvokeConstructor(gen);
    }
  }

  public void ArrayCreationExpr.createBCode(CodeGeneration gen) {
    if(hasArrayInit()){
      getArrayInit().createBCode(gen);
    }
    else {
      getTypeAccess().createBCode(gen); // push array sizes
      if(type().componentType().isPrimitive()) {
        gen.emit(Bytecode.NEWARRAY).add(type().componentType().arrayPrimitiveTypeDescriptor());
      }
      else {
        if(numArrays() == 1) {
          String n = type().componentType().arrayTypeDescriptor();
          int index = gen.constantPool().addClass(n);
          gen.emit(Bytecode.ANEWARRAY).add2(index);
        }
        else {
          String n = type().arrayTypeDescriptor();
          int index = gen.constantPool().addClass(n);
          gen.emit(Bytecode.MULTIANEWARRAY, 1 - numArrays()).add2(index).add(numArrays());
        }
      }
    }
  }

  public void ArrayInit.createBCode(CodeGeneration gen) {
    IntegerLiteral.push(gen, getNumInit());
    if(type().componentType().isPrimitive()) {
      gen.emit(Bytecode.NEWARRAY).add(type().componentType().arrayPrimitiveTypeDescriptor());
    }
    else {
      String n = type().componentType().arrayTypeDescriptor();
      int index = gen.constantPool().addClass(n);
      gen.emit(Bytecode.ANEWARRAY).add2(index);
    }
    for(int i = 0; i < getNumInit(); i++) {
      gen.emitDup();
      IntegerLiteral.push(gen, i);
      getInit(i).createBCode(gen);
      if(getInit(i) instanceof ArrayInit)
        gen.emit(Bytecode.AASTORE);
      else {
        getInit(i).type().emitAssignConvTo(gen, expectedType()); // AssignConversion
        gen.emit(expectedType().arrayStore());
      }
    }
  }

  public void ArrayTypeAccess.createBCode(CodeGeneration gen) {
    getAccess().createBCode(gen);
  }
  public void ArrayTypeWithSizeAccess.createBCode(CodeGeneration gen) {
    getAccess().createBCode(gen);
    getExpr().createBCode(gen);
  }

  syn String TypeDecl.arrayTypeDescriptor() { throw new Error("Operation not supported"); }
  eq ArrayDecl.arrayTypeDescriptor() = typeDescriptor();
  eq ClassDecl.arrayTypeDescriptor() = constantPoolName();
  eq InterfaceDecl.arrayTypeDescriptor() = constantPoolName();

  syn int TypeDecl.arrayPrimitiveTypeDescriptor() { error(); return -1; }
  eq BooleanType.arrayPrimitiveTypeDescriptor() = 4; // T_BOOLEAN
  eq CharType.arrayPrimitiveTypeDescriptor()    = 5; // T_CHAR
  eq FloatType.arrayPrimitiveTypeDescriptor()   = 6; // T_FLOAT
  eq DoubleType.arrayPrimitiveTypeDescriptor()  = 7; // T_DOUBLE
  eq ByteType.arrayPrimitiveTypeDescriptor()    = 8; // T_BYTE
  eq ShortType.arrayPrimitiveTypeDescriptor()   = 9; // T_SHORT
  eq IntType.arrayPrimitiveTypeDescriptor()     = 10; // T_INT
  eq LongType.arrayPrimitiveTypeDescriptor()    = 11; // T_LONG

  public void Unary.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    emitOperation(gen);
  }

  public void CastExpr.createBCode(CodeGeneration gen) {
    getExpr().createBCode(gen);
    getExpr().type().emitCastTo(gen, type());
  }

  // TODO: consider using IINC or WIDE,IINC

  public void Unary.emitPostfix(CodeGeneration gen, int constant) {
    Expr operand = getOperand();
    while(operand instanceof ParExpr)
      operand = ((ParExpr)operand).getExpr();
    Access access = ((Access)operand).lastAccess();
    access.createAssignLoadDest(gen);
    if(needsPush())
      access.createPushAssignmentResult(gen);
    TypeDecl type = access.type().binaryNumericPromotion(typeInt());
    type.emitPushConstant(gen, constant);
    type.add(gen);
    type.emitCastTo(gen, access.type());
    access.emitStore(gen);
  }
  public void PostIncExpr.createBCode(CodeGeneration gen) { emitPostfix(gen, 1); }
  public void PostDecExpr.createBCode(CodeGeneration gen) { emitPostfix(gen, -1); }

  public void Unary.emitPrefix(CodeGeneration gen, int constant) {
    Expr operand = getOperand();
    while(operand instanceof ParExpr)
      operand = ((ParExpr)operand).getExpr();
    Access access = ((Access)operand).lastAccess();
    access.createAssignLoadDest(gen);
    TypeDecl type = access.type().binaryNumericPromotion(typeInt());
    type.emitPushConstant(gen, constant);
    type.add(gen);
    type.emitCastTo(gen, access.type());
    if(needsPush())
      access.createPushAssignmentResult(gen);
    access.emitStore(gen);
  }
  public void PreIncExpr.createBCode(CodeGeneration gen) { emitPrefix(gen, 1); }
  public void PreDecExpr.createBCode(CodeGeneration gen) { emitPrefix(gen, -1); }

  public void Binary.createBCode(CodeGeneration gen) {
    getLeftOperand().createBCode(gen);
    getLeftOperand().type().emitCastTo(gen, type()); // Binary numeric promotion
    getRightOperand().createBCode(gen);
    getRightOperand().type().emitCastTo(gen, type()); // Binary numeric promotion
    emitOperation(gen);
  }

  public void Binary.emitShiftExpr(CodeGeneration gen) {
    getLeftOperand().createBCode(gen);
    getLeftOperand().type().emitCastTo(gen, type()); // Binary numeric promotion
    getRightOperand().createBCode(gen);
    getRightOperand().type().emitCastTo(gen, typeInt());
    emitOperation(gen);
  }
  public void LShiftExpr.createBCode(CodeGeneration gen) { emitShiftExpr(gen); }
  public void RShiftExpr.createBCode(CodeGeneration gen) { emitShiftExpr(gen); }
  public void URShiftExpr.createBCode(CodeGeneration gen) { emitShiftExpr(gen); }

  public void AddExpr.createBCode(CodeGeneration gen) {
    if(!type().isString())
      super.createBCode(gen);
    else if(isConstant()) {
      StringLiteral.push(gen, constant().stringValue());
    }
    else {
      TypeDecl stringBuffer = lookupType("java.lang", "StringBuffer");
      String classname = stringBuffer.constantPoolName();
      String desc;
      int index;
      TypeDecl argumentType;
      if(firstStringAddPart()) {
        stringBuffer.emitNew(gen); // new StringBuffer
        gen.emitDup();             // dup
        desc = "()V";
        index = gen.constantPool().addMethodref(classname, "<init>", desc);
        gen.emit(Bytecode.INVOKESPECIAL, -1).add2(index); // invokespecial StringBuffer()
        getLeftOperand().createBCode(gen); // left
        argumentType = getLeftOperand().type().stringPromotion();
        desc = "(" + argumentType.typeDescriptor() + ")" + stringBuffer.typeDescriptor();
        index = gen.constantPool().addMethodref(classname, "append", desc);
        gen.emit(Bytecode.INVOKEVIRTUAL, -argumentType.variableSize()).add2(index); // StringBuffer.append
      }
      else {
        getLeftOperand().createBCode(gen);
      }
      getRightOperand().createBCode(gen); // right
      argumentType = getRightOperand().type().stringPromotion();
      desc = "(" + argumentType.typeDescriptor() + ")" + stringBuffer.typeDescriptor();
      index = gen.constantPool().addMethodref(classname, "append", desc);
      gen.emit(Bytecode.INVOKEVIRTUAL, -argumentType.variableSize()).add2(index); // StringBuffer.append
      if (lastStringAddPart()) {
        desc = "()" + type().typeDescriptor();
        index = gen.constantPool().addMethodref(classname, "toString", desc);
        gen.emit(Bytecode.INVOKEVIRTUAL, 0).add2(index); // StringBuffer.toString
      }
    }
  }

  syn boolean Expr.canBeTrue() = !isFalse();
  eq CastExpr.canBeTrue() = getExpr().canBeTrue();
  eq ParExpr.canBeTrue() = getExpr().canBeTrue();
  eq AbstractDot.canBeTrue() = lastAccess().canBeTrue();
  eq OrLogicalExpr.canBeTrue() = getLeftOperand().canBeTrue() || getRightOperand().canBeTrue();
  eq AndLogicalExpr.canBeTrue() = getLeftOperand().canBeTrue() && getRightOperand().canBeTrue();
  eq ConditionalExpr.canBeTrue() =
    type().isBoolean() && (
        getCondition().canBeTrue() && getTrueExpr().canBeTrue()
        || getCondition().canBeFalse() && getFalseExpr().canBeTrue());
  eq LogNotExpr.canBeTrue() = getOperand().canBeFalse();

  syn boolean Expr.canBeFalse() = !isTrue();
  eq CastExpr.canBeFalse() = getExpr().canBeFalse();
  eq ParExpr.canBeFalse() = getExpr().canBeFalse();
  eq AbstractDot.canBeFalse() = lastAccess().canBeFalse();
  eq OrLogicalExpr.canBeFalse() = getLeftOperand().canBeFalse() && getRightOperand().canBeFalse();
  eq AndLogicalExpr.canBeFalse() = getLeftOperand().canBeFalse() || getRightOperand().canBeFalse();
  eq ConditionalExpr.canBeFalse() =
    type().isBoolean() && (
        getCondition().canBeTrue() && getTrueExpr().canBeFalse()
        || getCondition().canBeFalse() && getFalseExpr().canBeFalse());
  eq LogNotExpr.canBeFalse() = getOperand().canBeTrue();

  public void RelationalExpr.createBCode(CodeGeneration gen) { emitBooleanCondition(gen); }
  public void LogNotExpr.createBCode(CodeGeneration gen) { emitBooleanCondition(gen); }
  public void LogicalExpr.createBCode(CodeGeneration gen) { emitBooleanCondition(gen); }

  protected void Expr.emitBooleanCondition(CodeGeneration gen) {
    int end_label = -1;
    int false_label = -1;
    if (!isConstant()) {
      false_label = gen.constantPool().newLabel();
      emitEvalBranch(gen, false, false_label);
    }
    if (canBeTrue()) {
      BooleanLiteral.push(gen, true);
      if (canBeFalse()) {
        end_label = gen.constantPool().newLabel();
        gen.emitGoto(end_label);
        gen.changeStackDepth(-1); // discard value from stack depth computation
      }
    }
    if (false_label != -1) {
      gen.addLabel(false_label);
    }
    if (canBeFalse()) {
      BooleanLiteral.push(gen, false);
    }
    if (end_label != -1) {
      gen.addLabel(end_label);
    }
  }

  public void ConditionalExpr.createBCode(CodeGeneration gen) {
    int end_label = -1;
    int false_label = -1;
    if (!getCondition().isConstant()) {
      false_label = gen.constantPool().newLabel();
      getCondition().emitEvalBranch(gen, false, false_label);
    }
    if (getCondition().canBeTrue()) {
      getTrueExpr().createBCode(gen);
      getTrueExpr().type().emitCastTo(gen, type());
      if (getCondition().canBeFalse()) {
        end_label = gen.constantPool().newLabel();
        gen.emitGoto(end_label);
        gen.changeStackDepth(-type().variableSize());
      }
    }
    if (false_label != -1) {
      gen.addLabel(false_label);
    }
    if (getCondition().canBeFalse()) {
      getFalseExpr().createBCode(gen);
      getFalseExpr().type().emitCastTo(gen, type());
    }
    if (end_label != -1) {
      gen.addLabel(end_label);
    }
  }

  /**
   * Generate a branch statement. Potentially results in a conditional branch.
   * If invert is true, then fallthrough is used when the expression is true,
   * otherwise false falls through.
   * @param gen code generator
   * @param invert whether the condition should be inverted
   * @param target target label to jump to if the condition was false (or true
   * if inverted)
   */
  public void Expr.emitEvalBranch(CodeGeneration gen, boolean invert, int target) {
    if (!invert) {
      if (isConstant()) {
        if (isTrue()) {
          // fallthrough
        } else {
          gen.emitGoto(target);
        }
      } else {
        createBCode(gen);
        gen.emitCompare(Bytecode.IFEQ, target);
      }
    } else {
      if (isConstant()) {
        if (isTrue()) {
          gen.emitGoto(target);
        } else {
          // fallthrough
        }
      } else {
        createBCode(gen);
        gen.emitCompare(Bytecode.IFNE, target);
      }
    }
  }

  public void ParExpr.emitEvalBranch(CodeGeneration gen, boolean invert, int target) {
    getExpr().emitEvalBranch(gen, invert, target);
  }

  public void AbstractDot.emitEvalBranch(CodeGeneration gen, boolean invert, int target) {
    lastAccess().emitEvalBranch(gen, invert, target);
  }

  public void LogNotExpr.emitEvalBranch(CodeGeneration gen, boolean invert, int target)  {
    getOperand().emitEvalBranch(gen, !invert, target);
  }

  public void AndLogicalExpr.emitEvalBranch(CodeGeneration gen, boolean invert, int target) {
    if (!invert) {
      emitAndLogical(gen, false, target);
    } else {
      emitOrLogical(gen, true, target);
    }
  }

  public void OrLogicalExpr.emitEvalBranch(CodeGeneration gen, boolean invert, int target) {
    if (!invert) {
      emitOrLogical(gen, false, target);
    } else {
      emitAndLogical(gen, true, target);
    }
  }


  protected void Binary.emitOrLogical(CodeGeneration gen, boolean invert, int target) {
    if (!invert) {
      if (getLeftOperand().canBeFalse()) {
        int true_label = gen.constantPool().newLabel();
        getLeftOperand().emitEvalBranch(gen, true, true_label);
        getRightOperand().emitEvalBranch(gen, false, target);
        gen.addLabel(true_label);
      }
    } else {
      if (getLeftOperand().canBeTrue()) {
        int false_label = gen.constantPool().newLabel();
        getLeftOperand().emitEvalBranch(gen, false, false_label);
        getRightOperand().emitEvalBranch(gen, true, target);
        gen.addLabel(false_label);
      }
    }
  }

  protected void Binary.emitAndLogical(CodeGeneration gen, boolean invert, int target) {
    if (!invert) {
      if (getLeftOperand().canBeFalse()) {
        getLeftOperand().emitEvalBranch(gen, false, target);
      }
      if (!getLeftOperand().isFalse() && getRightOperand().canBeFalse()) {
        getRightOperand().emitEvalBranch(gen, false, target);
      }
    } else {
      if (getLeftOperand().canBeTrue()) {
        getLeftOperand().emitEvalBranch(gen, true, target);
      }
      if (!getLeftOperand().isTrue() && getRightOperand().canBeTrue()) {
        getRightOperand().emitEvalBranch(gen, true, target);
      }
    }
  }

  public void ConditionalExpr.emitEvalBranch(CodeGeneration gen, boolean invert, int target) {
    int end_label = -1;
    int else_label = -1;
    if (!invert) {
      if (!getCondition().isConstant()) {
        else_label = gen.constantPool().newLabel();
        getCondition().emitEvalBranch(gen, false, else_label);
      }
      if (getCondition().canBeTrue()) {
        getTrueExpr().emitEvalBranch(gen, false, target);
        if (getCondition().canBeFalse()) {
          end_label = gen.constantPool().newLabel();
          gen.emitGoto(end_label);
        }
      }
      if (else_label != -1) {
        gen.addLabel(else_label);
      }
      if (getCondition().canBeFalse()) {
        getFalseExpr().emitEvalBranch(gen, false, target);
      }
      if (end_label != -1) {
        gen.addLabel(end_label);
      }
    } else {
      if (!getCondition().isConstant()) {
        else_label = gen.constantPool().newLabel();
        getCondition().emitEvalBranch(gen, true, else_label);
      }
      if (getCondition().canBeFalse()) {
        getFalseExpr().emitEvalBranch(gen, true, target);
        if (getCondition().canBeTrue()) {
          end_label = gen.constantPool().newLabel();
          gen.emitGoto(end_label);
        }
      }
      if (else_label != -1) {
        gen.addLabel(else_label);
      }
      if (getCondition().canBeTrue()) {
        getTrueExpr().emitEvalBranch(gen, true, target);
      }
      if (end_label != -1) {
        gen.addLabel(end_label);
      }
    }
  }

  public void RelationalExpr.emitEvalBranch(CodeGeneration gen, boolean invert, int target) {
    if (!invert) {
      if (isTrue()) {
        // fallthrough
        return;
      } else if (isFalse()) {
        gen.emitGoto(target);
        return;
      }
    } else {
      if (isTrue()) {
        gen.emitGoto(target);
        return;
      } else if (isFalse()) {
        // fallthrough
        return;
      }
    }
    TypeDecl type = getLeftOperand().type();
    if (type.isNumericType()) {
      type = binaryNumericPromotedType();
      getLeftOperand().createBCode(gen);
      getLeftOperand().type().emitCastTo(gen, type); // Binary numeric promotion
      getRightOperand().createBCode(gen);
      getRightOperand().type().emitCastTo(gen, type); // Binary numeric promotion
    } else {
      getLeftOperand().createBCode(gen);
      getRightOperand().createBCode(gen);
    }
    if (!invert) {
      compareNotBranch(gen, target, type);
    } else {
      compareBranch(gen, target, type);
    }
  }

  public void RelationalExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    throw new Error("compareBranch not implemented for " + getClass().getName());
  }
  public void LTExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) { typeDecl.branchLT(gen, label); }
  public void LEExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) { typeDecl.branchLE(gen, label); }
  public void GEExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) { typeDecl.branchGE(gen, label); }
  public void GTExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) { typeDecl.branchGT(gen, label); }
  public void EQExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) { typeDecl.branchEQ(gen, label); }
  public void NEExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) { typeDecl.branchNE(gen, label); }

  public void RelationalExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    throw new Error("compareNotBranch not implemented for " + getClass().getName());
  }
  public void LTExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) { typeDecl.branchGEInv(gen, label); }
  public void LEExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) { typeDecl.branchGTInv(gen, label); }
  public void GEExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) { typeDecl.branchLTInv(gen, label); }
  public void GTExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) { typeDecl.branchLEInv(gen, label); }
  public void EQExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) { typeDecl.branchNE(gen, label); }
  public void NEExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) { typeDecl.branchEQ(gen, label); }

  public void InstanceOfExpr.createBCode(CodeGeneration gen) {
    getExpr().createBCode(gen);
    gen.emitInstanceof(getTypeAccess().type());
  }

  public void Stmt.createBCode(CodeGeneration gen) {
    gen.addLineNumberEntryAtCurrentPC(this);
  }

  public void Block.createBCode(CodeGeneration gen) {
    //super.createBCode(gen);
    for(int i = 0; i < getNumStmt(); i++) {
      try {
        getStmt(i).createBCode(gen);
      } catch (Exception e) {
        e.printStackTrace();
        throw new Error("Error generating code for " + errorPrefix() + " " + getStmt(i));
      }
    }
    gen.addVariableScopeLabel(variableScopeEndLabel(gen));
  }

  public void EmptyStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
  }

  syn lazy int LabeledStmt.label() = hostType().constantPool().newLabel();
  syn lazy int LabeledStmt.end_label() = hostType().constantPool().newLabel();
  public void LabeledStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    gen.addLabel(label());
    getStmt().createBCode(gen);
    gen.addLabel(end_label());
  }

  public void ExprStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    getExpr().createBCode(gen);
    if(needsPop())
      getExpr().type().emitPop(gen);
  }

  syn lazy DefaultCase SwitchStmt.defaultCase() {
    for(int i= 0; i < getBlock().getNumStmt(); i++) {
      if(getBlock().getStmt(i) instanceof DefaultCase)
        return (DefaultCase)getBlock().getStmt(i);
    }
    return null;
  }

  syn lazy int SwitchStmt.end_label() = hostType().constantPool().newLabel();

  public void SwitchStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    int switch_label = gen.constantPool().newLabel();

    getExpr().createBCode(gen);

    TreeMap<Integer, ConstCase> map = new TreeMap<Integer, ConstCase>();
    for (int i = 0; i < getBlock().getNumStmt(); i++) {
      if (getBlock().getStmt(i) instanceof ConstCase) {
        ConstCase ca = (ConstCase)getBlock().getStmt(i);
        map.put(ca.getValue().constant().intValue(), ca);
      }
    }

    int low = map.isEmpty() ? 0 : map.firstKey();
    int high = map.isEmpty() ? 0 : map.lastKey();

    int tableSwitchSize = 4 * (3 + (high - low + 1));
    int lookupSwitchSize = 4 * (2 + 2 * map.size());
    int pad;
    int switchSize;
    int switchPos;
    boolean tableSwitch = tableSwitchSize < lookupSwitchSize;

    gen.addLabel(switch_label);

    // Select the switch type which produces the smallest switch instr.
    if (tableSwitch) {
      // TABLESWITCH
      gen.emit(Bytecode.TABLESWITCH);
      switchSize = tableSwitchSize;
    } else {
      // LOOKUPSWITCH
      gen.emit(Bytecode.LOOKUPSWITCH);
      switchSize = lookupSwitchSize;
    }

    pad = emitPad(gen);
    switchPos = gen.pos();

    // leave room for the address table
    gen.skip(switchSize);

    getBlock().createBCode(gen);

    // write jump address table
    int endpos = gen.pos();
    gen.setPos(switchPos);
    if (tableSwitch) {
      int defaultOffset = defaultOffset(gen, switch_label);
      int numCase = high - low + 1;
      if(defaultOffset == 0) {
        defaultOffset = 1 + pad + switchSize;
      }
      gen.add4(defaultOffset);
      gen.add4(low);
      gen.add4(high);
      for (int i = low; i <= high; i++) {
        ConstCase ca = map.get(i);
        if (ca != null) {
          int offset = gen.addressOf(ca.label())
            - gen.addressOf(switch_label);
          gen.add4(offset);
        } else {
          gen.add4(defaultOffset);
        }
      }
    } else {
      int defaultOffset = defaultOffset(gen, switch_label);
      if (defaultOffset == 0) {
        defaultOffset = 1 + pad + switchSize;
      }
      gen.add4(defaultOffset);
      gen.add4(map.size());
      for (ConstCase ca : map.values()) {
        gen.add4(ca.getValue().constant().intValue());
        int offset = gen.addressOf(ca.label())
          - gen.addressOf(switch_label);
        gen.add4(offset);
      }
    }
    gen.setPos(endpos);

    gen.addLabel(end_label());
  }

  syn int SwitchStmt.numCase() {
    int result = 0;
    for(int i = 0; i < getBlock().getNumStmt(); i++)
      if(getBlock().getStmt(i) instanceof Case)
        result++;
    return result;
  }

  private int SwitchStmt.emitPad(CodeGeneration gen) {
    int pad = (4 - (gen.pos() % 4)) % 4;
    for (int i = 0; i < pad; i++) {
      gen.emit(Bytecode.NOP);
    }
    if (gen.pos() % 4 != 0) {
      throw new Error("Switch not at 4-byte boundary:" + gen.pos());
    }
    return pad;
  }

  /**
   * Calculate offset to the default label.
   * @return bytecode offset to default label (or zero if there is no
   * default label)
   */
  private int SwitchStmt.defaultOffset(CodeGeneration gen, int switch_label) {
    DefaultCase defaultCase = defaultCase();
    if (defaultCase != null) {
      int offset = gen.addressOf(defaultCase.label())
        - gen.addressOf(switch_label);
      return offset;
    }
    return 0;
  }

  syn lazy int Case.label() = hostType().constantPool().newLabel();

  public void Case.createBCode(CodeGeneration gen) {
    gen.addLabel(label());
  }

  syn lazy int IfStmt.else_branch_label() = hostType().constantPool().newLabel();
  syn lazy int IfStmt.then_branch_label() = hostType().constantPool().newLabel();
  syn lazy int IfStmt.end_label() = hostType().constantPool().newLabel();
  public void IfStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    int elseBranch = else_branch_label();
    int thenBranch = then_branch_label();
    int endBranch = end_label();
    if (!getCondition().isConstant()) {
      getCondition().emitEvalBranch(gen, false, elseBranch);
    }
    gen.addLabel(thenBranch);
    if (getCondition().canBeTrue()) {
      getThen().createBCode(gen);
      if (getThen().canCompleteNormally() && hasElse() && getCondition().canBeFalse()) {
        gen.emitGoto(endBranch);
      }
    }
    gen.addLabel(elseBranch);
    if (hasElse() && getCondition().canBeFalse()) {
      getElse().createBCode(gen);
    }
    gen.addLabel(endBranch);
  }

  syn lazy int WhileStmt.cond_label() = hostType().constantPool().newLabel();
  syn lazy int WhileStmt.end_label() = hostType().constantPool().newLabel();
  syn lazy int WhileStmt.stmt_label() = hostType().constantPool().newLabel();

  public void WhileStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    gen.addLabel(cond_label());
    if (!getCondition().isConstant()) {
      getCondition().emitEvalBranch(gen, false, end_label());
    }
    gen.addLabel(stmt_label());
    if (getCondition().canBeTrue()) {
      getStmt().createBCode(gen);
      if (getStmt().canCompleteNormally()) {
        gen.emitGoto(cond_label());
      }
    }
    gen.addLabel(end_label());
  }

  syn lazy int DoStmt.begin_label() = hostType().constantPool().newLabel();
  syn lazy int DoStmt.cond_label() = hostType().constantPool().newLabel();
  syn lazy int DoStmt.end_label() = hostType().constantPool().newLabel();

  public void DoStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    gen.addLabel(begin_label());
    getStmt().createBCode(gen);
    gen.addLabel(cond_label());
    getCondition().emitEvalBranch(gen, true, begin_label());
    gen.addLabel(end_label());
  }

  syn lazy int ForStmt.cond_label() = hostType().constantPool().newLabel();
  syn lazy int ForStmt.begin_label() = hostType().constantPool().newLabel();
  syn lazy int ForStmt.update_label() = hostType().constantPool().newLabel();
  syn lazy int ForStmt.end_label() = hostType().constantPool().newLabel();

  public void ForStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    for (int i=0; i<getNumInitStmt(); i++) {
      getInitStmt(i).createBCode(gen);
    }
    gen.addLabel(cond_label());
    if (!getCondition().isConstant()) {
      getCondition().emitEvalBranch(gen, false, end_label());
    }
    if (getCondition().canBeTrue()) {
      gen.addLabel(begin_label());
      getStmt().createBCode(gen);
      gen.addLabel(update_label());
      for (int i=0; i<getNumUpdateStmt(); i++)
        getUpdateStmt(i).createBCode(gen);
      gen.emitGoto(cond_label());
    }
    if (canCompleteNormally()) {
      gen.addLabel(end_label());
    }
    gen.addVariableScopeLabel(variableScopeEndLabel(gen));
  }

  syn int Stmt.break_label() {
    throw new UnsupportedOperationException("Can not break at this statement of type " + getClass().getName());
  }
  eq ForStmt.break_label() = end_label();
  eq WhileStmt.break_label() = end_label();
  eq DoStmt.break_label() = end_label();
  eq LabeledStmt.break_label() = end_label();
  eq SwitchStmt.break_label() = end_label();
  eq TryStmt.break_label() =  label_end();
  syn lazy int SynchronizedStmt.start_label() = hostType().constantPool().newLabel();

  public void BreakStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    if (hasFinally()) {
      int nextRange = gen.constantPool().newLabel();
      getFinally().createBCode(gen);
      gen.emitGoto(targetStmt().break_label());
      gen.addLabel(nextRange);
      gen.monitorRangesStart(this, nextRange);
    } else {
      gen.emitGoto(targetStmt().break_label());
    }
  }

  syn int Stmt.continue_label() {
    throw new UnsupportedOperationException("Can not continue at this statement");
  }
  eq ForStmt.continue_label() = update_label();
  eq WhileStmt.continue_label() = cond_label();
  eq DoStmt.continue_label() = cond_label();
  eq LabeledStmt.continue_label() = getStmt().continue_label();

  // TODO: test continue in try-statement!!!
  eq TryStmt.continue_label() = label_end();

  public void ContinueStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    if (hasFinally()) {
      int nextRange = gen.constantPool().newLabel();
      getFinally().createBCode(gen);
      gen.emitGoto(targetStmt().continue_label());
      gen.addLabel(nextRange);
      gen.monitorRangesStart(this, nextRange);
    } else {
      gen.emitGoto(targetStmt().continue_label());
    }
  }

  public void ReturnStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    if(hasResult()) {
      TypeDecl type = null;
      BodyDecl b = enclosingBodyDecl();
      if(b instanceof MethodDecl) {
        type = ((MethodDecl)b).type();
      }
      else {
        throw new Error("Can not create code that returns value within non method");
      }
      getResult().createBCode(gen);
      getResult().type().emitCastTo(gen, type);
      if (hasFinally()) {
        int nextRange = gen.constantPool().newLabel();
        type.emitStoreLocal(gen, resultSaveLocalNum());
        getFinally().createBCode(gen);
        type.emitLoadLocal(gen, resultSaveLocalNum());
        type.emitReturn(gen);
        gen.addLabel(nextRange);
        gen.monitorRangesStart(this, nextRange);
      } else {
        type.emitReturn(gen);
      }
    } else {
      if (hasFinally()) {
        int nextRange = gen.constantPool().newLabel();
        getFinally().createBCode(gen);
        gen.emitReturn();
        gen.addLabel(nextRange);
        gen.monitorRangesStart(this, nextRange);
      } else {
        gen.emitReturn();
      }
    }
  }

  public void ThrowStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    getExpr().createBCode(gen);
    gen.emitThrow();
  }

  syn lazy int TryStmt.fallthrough_label() =
    hasNonEmptyFinally() ? hostType().constantPool().newLabel() : label_end();

  public void TryStmt.createBCode(CodeGeneration gen) {
    int block_top_lbl = gen.constantPool().newLabel();
    int block_end_lbl = gen.constantPool().newLabel();
    int fallthrough_lbl = fallthrough_label();
    int handler_lbl = gen.constantPool().newLabel();
    boolean needsHandler = false;

    super.createBCode(gen);
    gen.addLabel(block_top_lbl);
    getBlock().createBCode(gen);
    gen.addLabel(block_end_lbl);

    if (getBlock().canCompleteNormally()) {
      gen.emitGoto(fallthrough_lbl);
    }

    for (int i = 0; i < getNumCatchClause(); i++) {
      CatchClause cc = getCatchClause(i);
      cc.createBCode(gen);
      cc.exceptionTableEntries(gen, block_top_lbl, block_end_lbl);
      if (cc.getBlock().canCompleteNormally()) {
        gen.emitGoto(fallthrough_lbl);
      }
      if (hasNonEmptyFinally()) {
        int cc_end_lbl = gen.constantPool().newLabel();
        gen.addLabel(cc_end_lbl);
        needsHandler = true;
        gen.addException(cc.label(), cc_end_lbl, handler_lbl,
            CodeGeneration.ExceptionEntry.CATCH_ALL);
      }
    }

    if (hasNonEmptyFinally()) {

      emitExceptionHandler(gen, block_top_lbl, block_end_lbl, handler_lbl,
          needsHandler);

      // fallthrough finally
      gen.addLabel(fallthrough_lbl);
      getFinally().createBCode(gen);
    }

    gen.addLabel(label_end());
  }

  /**
   * Outer finally host with a finally block that can complete normally
   */
  syn FinallyHost TryStmt.outerFinallyHost() {
    // find outer finally
    FinallyHost outer = this;
    Iterator<FinallyHost> iter = finallyIterator();
    while (iter.hasNext()) {
      outer = iter.next();
    }
    return outer;
  }

  /**
   * Generate catch-all (finally)
   */
  public void TryStmt.emitExceptionHandler(CodeGeneration gen, int start_lbl, int end_lbl, int handler_lbl, boolean needsHandler) {
    int top_pc = gen.addressOf(start_lbl);
    int end_pc = gen.addressOf(end_lbl);
    if (needsHandler || top_pc != end_pc) {
      // catch-all exception handler (finally)
      gen.addLabel(handler_lbl);
      gen.changeStackDepth(1);
      int num = getBlock().localNum();
      gen.emitStoreReference(num);
      getExceptionHandler().createBCode(gen);
      gen.emitLoadReference(num);
      gen.emit(Bytecode.ATHROW);

      gen.addException(start_lbl, end_lbl, handler_lbl,
          CodeGeneration.ExceptionEntry.CATCH_ALL);
    }
  }

  public void SynchronizedStmt.emitMonitorEnter(CodeGeneration gen) {
    gen.emitDup();
    int num = localNum();
    gen.emitStoreReference(num);
    gen.emit(Bytecode.MONITORENTER);
  }

  syn lazy int CatchClause.label() = hostType().constantPool().newLabel();
  public void BasicCatch.createBCode(CodeGeneration gen) {
    gen.addLabel(label());
    // add 1 to stack depth
    gen.changeStackDepth(1);
    getParameter().type().emitStoreLocal(gen, getParameter().localNum());
    getBlock().createBCode(gen);
  }

  protected int SynchronizedStmt.monitorId = -1;

  public void SynchronizedStmt.createBCode(CodeGeneration gen) {
    int lbl_start = gen.constantPool().newLabel();
    super.createBCode(gen);
    getExpr().createBCode(gen);

    monitorId = gen.monitorEnter(this);
    gen.addLabel(lbl_start);
    gen.monitorRangeStart(monitorId, lbl_start);

    getBlock().createBCode(gen);

    if (getBlock().canCompleteNormally()) {
      getMonitorExit().createBCode(gen);
      gen.emitGoto(label_end());
    }

    gen.monitorExit();

    gen.addLabel(label_end());
  }

  /**
   * Checks if the branch statement leaves the monitor.
   * @return <code>true</code> if the branch leaves the monitor
   */
  inh boolean Stmt.leavesMonitor(Stmt branch, SynchronizedStmt monitor);

  eq BodyDecl.getChild().leavesMonitor(Stmt branch, SynchronizedStmt monitor) {
    throw new Error("Enclosing monitor not found!");
  }

  eq SynchronizedStmt.getChild().leavesMonitor(Stmt branch, SynchronizedStmt monitor) {
    if (monitor == this)
      return true;
    else
      return leavesMonitor(branch, monitor);
  }

  eq BranchTargetStmt.getChild().leavesMonitor(Stmt branch, SynchronizedStmt monitor) {
    if (potentialTargetOf(branch))
      return false;
    else
      return leavesMonitor(branch, monitor);
  }

  /**
   * Assert statement bytecode is generated through the transformed
   * version of the assert statement!
   *
   * @see java4/backend/Transformations.jrag
   */
  public void AssertStmt.createBCode(CodeGeneration gen) {
    throw new UnsupportedOperationException("Assert not yet implemented");
  }

  public void LocalClassDeclStmt.createBCode(CodeGeneration gen) {
  }

  public void ClassAccess.createBCode(CodeGeneration gen) {
    if(prevExpr().type().isPrimitiveType() || prevExpr().type().isVoid()) {
      TypeDecl typeDecl = lookupType("java.lang", prevExpr().type().primitiveClassName());
      SimpleSet c = typeDecl.memberFields("TYPE");
      FieldDeclaration f = (FieldDeclaration)c.iterator().next();
      f.emitLoadField(gen, typeDecl);
    }
    else {
      FieldDeclaration f = hostType().topLevelType().createStaticClassField(prevExpr().type().referenceClassFieldName());
      // add method to perform lookup as a side-effect
      MethodDecl m = hostType().topLevelType().createStaticClassMethod();

      int next_label = gen.constantPool().newLabel();
      int end_label = gen.constantPool().newLabel();
      f.emitLoadField(gen, hostType());
      gen.emitBranchNonNull(next_label);

      // emit string literal

      StringLiteral.push(gen, prevExpr().type().jvmName());
      m.emitInvokeMethod(gen, hostType());
      gen.emitDup();
      f.emitStoreField(gen, hostType());
      gen.emitGoto(end_label);
      gen.addLabel(next_label);
      gen.changeStackDepth(-1);
      f.emitLoadField(gen, hostType());
      gen.addLabel(end_label);
    }
  }

  /**
   * Generate bytecode for the monitor exit call.
   */
  public void MonitorExit.createBCode(CodeGeneration gen) {
    gen.monitorRangeEnd(monitor.monitorId,
        hostType().constantPool().newLabel());
  }

  /**
   * Generate exception handler for monitor closing.
   * @param gen
   */
  public void MonitorExit.emitMonitorExitHandler(CodeGeneration gen) {
    int handler_lbl = handler_label();
    int end_lbl = handler_end_label();

    gen.changeStackDepth(1);
    int num = localNum() + 1;

    // handler start
    gen.addLabel(handler_lbl);

    gen.emitStoreReference(num);

    gen.emitLoadReference(monitor.localNum());
    gen.emit(Bytecode.MONITOREXIT);

    // handler end
    gen.addLabel(end_lbl);

    gen.emitLoadReference(num);
    gen.emit(Bytecode.ATHROW);

    // add exception handler for the monitor closing
    // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4414101
    gen.addException(handler_lbl, end_lbl, handler_lbl,
        CodeGeneration.ExceptionEntry.CATCH_ALL);

  }
}
